---
title: "diaQTL Vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{diaQTL Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE,collapse=FALSE,message = FALSE,comment="##",fig.width=5,fig.height=5)
knitr::opts_knit$set(root.dir="~/")  
```

The example data set is a 3x3 half-diallel population in potato. In other words, three founders were crossed in all three pairwise combinations. 

## Structure of the input files
Three input files are needed for QTL analysis: (1) pedigree file, (2) genotype file, (3) phenotype file. In most situations, the PolyOrigin software will be used prior to running diaQTL. The diaQTL function `read_polyancestry` can be used to generate the pedigree and genotype input files from the PolyOrigin output file. 

### 1) Pedigree file
The pedigree file has three columns: id, parent1, and parent2 (maternal effects are not modeled). 
```{r}
pedcsv <- system.file("vignette_data", "potato_ped.csv", package = "diaQTL")
ped <- read.csv(pedcsv, as.is = T)
head(ped)
table(apply(ped[,2:3],1,paste,collapse=" x "))
```

### 2) Genotype file
The first 3 columns of the genotype file must be labeled marker, chrom, and cM, and the position in a reference genome (labeled bp) is optional as the fourth column (plotting features can use either cM or bp). Subsequent columns contain the genotype probabilities for each individual. 
```{r}
genocsv <- system.file( "vignette_data", "potato_geno.csv", package = "diaQTL" )
geno <- read.csv( genocsv, as.is = T, check.names = F )
geno[1:5,1:4]
```
Genotype probabilities are encoded as strings, following the format exported by the PolyOrigin software:
```{r}
geno[1,10]
```
The integers separated by | on the left side of the equal sign refer to genotype states, and the decimal numbers on the right side of the equal sign are probabilities. Only nonzero probabilities need to be included. There are 100 possible states for F1 populations, and 35 possible states for S1 populations:
```{r}
library( diaQTL )
head( F1codes )
head( S1codes )
```
Each state has four integers, separated by dashes, to indicate which parental chromosomes were inherited. For F1 populations, the maternal chromosomes are labeled 1-4 and the paternal chromosomes 5-8. 

### 3) Phenotype file
In the phenotype input file, the first column should be the individual identifier, followed by columns for different traits, and then optionally any columns with fixed effects to include in the linear model (e.g., block, environment). Only one trait, tuber shape, is provided in the example potato data set.

```{r}
phenocsv <- system.file( "vignette_data", "potato_pheno.csv", package = "diaQTL" )
pheno <- read.csv( phenocsv, as.is = T )
head( pheno )
hist(pheno$tuber_shape,main="",xlab="Tuber shape")
```

To improve normality of the residuals, tuber shape in this data set is defined as log(L/W - 1), where L/W is the average length/width ratio of tubers weighing 6-10 ounces (170-285g). 

## Read the data
After installing and attaching the package, use `read_data` to read in all three files. (If there are fixed effects in the phenotype input file, they need to be specified as well; consult the reference manual.) By default, markers with the same map position in cM (using whatever numerical precision is present in the input map) are binned to reduce the computing time. The argument `n.core = 2` is used for parallel execution on multiple cores.
```{r eval=FALSE}
data <- read_data(genofile = genocsv,
                  ploidy = 4,
                  pedfile = pedcsv,
                  phenofile = phenocsv, 
                  n.core = 2)
```
```{r include=FALSE}
load("~/Box Sync/Endelman/Software/diaQTL/data.rda")
```

## Setting parameters
diaQTL uses Bayesian regression methods from R package BGLR, which are based on Markov Chain Monte Carlo (MCMC). The function `set_params` determines the burn-in and total number of iterations using the Raftery and Lewis diagnostic from R package `coda`, based on a 95% probability that the estimate for quantile `q` of the additive effects is within the interval `(q-r,q+r)`. For the genome scan, we have found the results based on `q=0.5,r=0.1` to be adequate. Because MCMC is a stochastic process, the results will not be the same each time.
```{r}
params <- set_params( data, trait = "tuber_shape", q=0.5, r=0.1)
params
```

## Single QTL scan
The `scan1` function performs a single QTL scan by regression of the phenotypes on the genotype probabilities. By default, dominance is not incuded in the scan because it takes longer. However, there may be traits where dominance is needed for QTL detection or to refine the QTL position. It is also possible to restrict the QTL scan to a subset of chromosomes. Consult the reference manual for these options.
```{r}
scan1_example <- scan1( data = data,
                        trait = "tuber_shape",
                        params = params, 
                        n.core = 2)
```

## Detection threshold
The function `LODthresh` can be used to estimate the LOD threshold corresponding to a genome-wide false positive rate of 0.05. This function uses a curve fit to simulated datasets with no QTL, which produces results similar to a permutation test (which is also available via the function `scan1_permute`). The genome size for the potato dataset can be estimated from the genetic map.
```{r }
sum(tapply(data@map$cM,data@map$chrom,max))/100 #Morgans 
LODthresh(genome.size=12.1,num.parents=3,ploidy=4) #threshold
```

## Results
The `scan1_summary` function returns the marker with the highest LOD score on each chromosome and a plot of the LOD profile. 
```{r}
ans1 <- scan1_summary(scan1_example,thresh=6.8,position="bp")
ans1$peaks
ans1$plot
```

The results show there is a QTL on chromosome 10, and the most significant marker is solcap_snp_c2_25522. The 90% Bayesian credible interval (CI) for the QTL can be obtained using `BayesCI`:
```{r}
BayesCI(scan1_example,data,chrom="10",CI.prob=0.9)
```

This region coincides with the location of the classical Ro (round) QTL in potato, which was recently identified as the gene *StOFP20* [(Wu et al. 2018)](https://doi.org/10.1038/s41467-018-07216-8). 

Function `fitQTL` is used to get the estimated haplotype effects at the most significant marker, as both a table (`effects`) and barplot (`plots`). The argument `polygenic` controls whether to include an additive polygenic effect in the model, with covariance proportional to the realized relationship matrix (computed by `IBDmat`). The argument `dominance` controls the genetic model used for the QTL effect. A value of 1 indicates the additive model; 2 is a model with additive and digenic dominance effects; 3 includes additive, digenic and trigenic effects; and 4 includes all effects up to quadrigenic dominance. To estimate a 90% Bayesian CI for the effects, the number of MCMC iterations is increased based on the output from `set_params`. 
```{r}
params <- set_params( data, trait = "tuber_shape", 
                      marker = "solcap_snp_c2_25522", q=0.05, r=0.025, dominance = 2)
params

# Simplest model, includes additive effect for QTL and no polygenic term
fit1 <- fitQTL( data = data, 
                trait = "tuber_shape", 
                params = params,
                dominance = 1, 
                polygenic = FALSE,
                marker = "solcap_snp_c2_25522",
                CI.prob = 0.9)

# Now add polygenic effect
fit1p <- fitQTL( data = data, 
                 trait = "tuber_shape", 
                 params = params, 
                 marker = "solcap_snp_c2_25522",
                 dominance = 1,
                 polygenic = TRUE,
                 CI.prob = 0.9)

# Include digenic dominance
fit2 <- fitQTL( data = data, 
                trait = "tuber_shape", 
                params = params, 
                marker = "solcap_snp_c2_25522",
                dominance = 2,
                polygenic = TRUE,
                CI.prob = 0.9)

# Include trigenic dominance
fit3 <- fitQTL( data = data, 
                trait = "tuber_shape", 
                params = params, 
                marker = "solcap_snp_c2_25522",
                dominance = 3,
                polygenic = TRUE,
                CI.prob = 0.9)

deltaDIC <- round(sapply(list(fit1,fit1p,fit2,fit3),"[[",'deltaDIC'),0)
models <- c("Add","Add+Poly","Add+Digenic+Poly","Add+Digenic+Trigenic+Poly")
print(data.frame(models,deltaDIC))
```

One of the elements of the list returned by `fitQTL` is named `deltaDIC`, which is the Deviance Information Criterion (DIC) for the QTL model relative to the null (no QTL) model. Lower values of DIC indicate a better tradeoff between model complexity and goodness-of-fit (i.e., higher likelihood), and a [difference of at least 5](https://www.mrc-bsu.cam.ac.uk/software/bugs/the-bugs-project-dic/#q9) is typically recommended. In this case, the model with additive and digenic QTL effects, plus the additive polygenic effect, is selected. 

The proportion of variance for the QTL and polygenic effects is returned in `var`:
```{r}
fit2$var
fit2$plots$add
```

The error bars on the additive effects correspond to the 90% CI in this example. Although they appear quite large, the relative order of the haplotype effects should be very reliable for a population of this size, based on simulation studies [(Amadeu et al. 2020)](https://doi.org/10.1101/2020.12.18.423479). The dominance plot shows the digenic effects above the diagonal, and below the diagonal is the sum of the additive and digenic effects:
```{r}
fit2$plots$dom
```


The largest additive effect (in magnitude) corresponds to haplotype W6511-1R.2. The function `haplo_get` can be used to extract the dosage of this haplotype across the population.
```{r}
haplos <- haplo_get( data = data, 
                      marker = "solcap_snp_c2_25522")
hist(haplos[,"W6511-1R.2"],main="",xlab="Dosage")
which(haplos[,"W6511-1R.2"] > 1.8)
```

The result shows there are three individuals with two copies of the W6511-1R.2 haplotype, which is possible due to "double reduction." This occurs when a quadrivalent forms in meiosis I and sister chromatid fragments migrate to the same pole in meiosis II. The function `haplo_plot` can be used to visualize the pattern of recombination between parental haplotypes.
```{r}
haplo_plot( data = data, 
            id = "W15268-53R", 
            chrom = 10,
            position = "bp",
            marker = "solcap_snp_c2_25522" )
```

The dark blue segment indicates two copies of the W6511-1R.2 haplotype, and the dashed vertical line shows the position of the QTL at 49 Mb.

## Multiple QTL mapping
Both `scan1` and `fitQTL` allow for the inclusion of a second marker as a `cofactor` in the analysis. The cofactor model can include dominance as well as additive x additive epistasis with the primary QTL. Consult the reference manual for more details.
